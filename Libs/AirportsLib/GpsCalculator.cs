using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Eng.EFsExtensions.Libs.AirportsLib
{
  public static class GpsCalculator
  {
    #region Private Fields

    private const double EarthRadiusKm = 6371.0;

    #endregion Private Fields

    // Earth's radius in kilometers

    #region Public Methods

    public static double GetDistance(GPS a, GPS b) => GetDistance(a.Latitude, a.Longitude, b.Latitude, b.Longitude);

    public static double GetDistance(double lat1, double lon1, double lat2, double lon2)
    {
      const double R = 6371; // Radius of the Earth in kilometers
      double dLat = ToRadians(lat2 - lat1);
      double dLon = ToRadians(lon2 - lon1);

      double a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                 Math.Cos(ToRadians(lat1)) * Math.Cos(ToRadians(lat2)) *
                 Math.Sin(dLon / 2) * Math.Sin(dLon / 2);

      double c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));

      double distanceInM = R * c * 1000; // Distance in ometers

      return distanceInM;
    }

    public static double GetDistanceFromLine(GPS aLine, GPS bLine, GPS point,char unit = 'K') 
      => GetDistanceFromLine(aLine.Latitude, aLine.Longitude, bLine.Latitude, bLine.Longitude, point.Latitude, point.Longitude, unit);

    public static double GetDistanceFromLine(double lat1, double lon1, double lat2, double lon2, double latP, double lonP, char unit = 'K')
    {
      double d13 = GetDistance(lat1, lon1, latP, lonP) / EarthRadiusKm; // Distance from P to A (normalized)
      double brng13 = InitialBearing(lat1, lon1, latP, lonP);
      double brng12 = InitialBearing(lat1, lon1, lat2, lon2);

      double ret = Math.Asin(Math.Sin(d13) * Math.Sin(ToRadians(brng13 - brng12))) * EarthRadiusKm;
      ret = Math.Abs(ret);
      return ret;
    }

    public static double InitialBearing(GPS a, GPS b) => InitialBearing(a.Latitude, a.Longitude, b.Latitude, b.Longitude);

    public static double InitialBearing(double lat1, double lon1, double lat2, double lon2)
    {
      double dLon = ToRadians(lon2 - lon1);
      double phi1 = ToRadians(lat1);
      double phi2 = ToRadians(lat2);

      double y = Math.Sin(dLon) * Math.Cos(phi2);
      double x = Math.Cos(phi1) * Math.Sin(phi2) - Math.Sin(phi1) * Math.Cos(phi2) * Math.Cos(dLon);

      return (ToDegrees(Math.Atan2(y, x)) + 360) % 360;
    }

    public static double GetApproximateDeclination(GPS gps) => GetApproximateDeclination(gps.Latitude, gps.Longitude);

    public static double GetApproximateDeclination(double lat, double lon)
    {
      // generated by ChatGPT, have no idea what exactly this is calculated
      double baseDeclination = -6.0;
      double declination = baseDeclination + (lon / 30.0);

      // Small correction for north hemishpere
      declination += (lat - 50) * 0.1;

      return declination;
    }

    #endregion Public Methods

    #region Private Methods

    private static double ToDegrees(double radians) => radians * (180 / Math.PI);

    private static double ToRadians(double degrees) => degrees * (Math.PI / 180);

    #endregion Private Methods
  }
}
